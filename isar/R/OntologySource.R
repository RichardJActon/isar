
# implement term_validator function instead of term list
# e.g. for a unit a value could be valid if it conforms to a rule
# such as is it an integer?


#' R6 class for the source of ontology terms
#'
#' An [OntologySource] describes the resource from which the value of an [OntologyAnnotation] is derived from.
#'
#' @field name The name of the source of a term; i.e. the source controlled vocabulary or ontology.
#' @field file A file name or a URI of an official resource.
#' @field file_type the file type, parsable by \code{rdflib::rdf_parse()}
#' @field url ...
#' @field version version of the ontology
#' @field description free text description of this source of ontology terms
#' @field get_terms_list function to generate valid terms for file
#' @field terms_list list of valid terms where keys are terms and values accessions
#' @field comments comments
#' @field explicitly_provided Was this [OntologySource] provided in the
#' list of [OntologySourceReferences] for the [Investigation] (TRUE) or was
#' it dynamically generated (FALSE)?
#' @field source the source of the [OntologySource] object, was it listed in
#' an investigation ontolgoy source reference list, elsewhere or auto generated
#'
#' @importFrom R6 R6Class
#' @importFrom checkmate qtest check_string check_list
#' @importFrom glue glue
# #' @importFrom crayon green yellow bold italic
#' @importFrom cli cli_h1 cli_h2 cli_text col_yellow style_italic
#' @importFrom purrr iwalk
# #' @importFrom stringr str_wrap
#'
#' @export
OntologySource <- R6::R6Class(
	"OntologySource",
	public = list(
		name = character(),
		file = character(),
		file_type = character(),
		url = character(),
		version = character(),
		description = character(),
		get_terms_list = NULL,
		terms_list = NULL,
		comments = NULL,
		explicitly_provided = logical(),
		source = character(),
		#' @details
		#'
		#' Create a new [OntologySource] object to act as source for ontology terms
		#'
		#' @param name The name of the source of a term; i.e. the source controlled vocabulary or ontology.
		#' @param file A file name or a URI of an official resource.
		#' @param file_type the file type, parsable by \code{rdflib::rdf_parse()}
		#' @param url ...
		#' @param version vesion of the ontology
		#' @param description free text description of this source of ontology terms
		#' @param get_terms_list function to generate valid terms for file
		#' @param terms_list list of valid terms where keys are terms and values accessions
		#' @param comments comments
		#' @param explicitly_provided Was this [OntologySource] provided in the
		#' list of [OntologySourceReferences] for the [Investigation] (TRUE) or was
		#' it dynamically generated (FALSE)?
		#' @param source the source of the [OntologySource] object, was it listed in
		#' an investigation ontolgoy source reference list, elsewhere or auto generated
		initialize = function(
			name = character(),
			file = character(),
			file_type = character(),
			url = character(),
			version = character(),
			description = character(),
			get_terms_list = NULL,
			terms_list = NULL,
			comments = NULL,
			explicitly_provided = logical(),
			source = character()
		) {
			if (checkmate::qtest(name, "S[0]")) { self$name <- name } else {
				self$set_name(name)
			}
			if (checkmate::qtest(file, "S[0]")) { self$file <- file } else {
				self$set_file(file)
			}
			if (checkmate::qtest(file_type, "S[0]")) {
				self$file_type <- file_type
			} else {
				self$set_file_type(file_type)
			}
			if (checkmate::qtest(url, "S[0]")) { self$url <- url } else {
				self$set_url(url)
			}
			if (checkmate::qtest(version, "S[0]")) {
				self$version <- version
			} else {
				self$set_version(version)
			}
			if (checkmate::qtest(description, "S[0]")) {
				self$description <- description
			} else {
				self$set_description(description)
			}
			self$set_comments(comments)

			self$get_terms_list <- get_terms_list

			if (is.null(terms_list) && is.null(get_terms_list)) {
				self$terms_list <- terms_list
				self$get_terms_list <- get_terms_list
			}

			if(!is.null(terms_list) && !is.null(get_terms_list)) {
				warning(glue::glue(
					.sep = "\n",
					"Both terms_list and get_terms_list are specified.",
					"The manually specified terms list will take precedence over the one generated by the get_terms_list function"
				))
			}

			if(
				(!is.function(get_terms_list) && !is.null(get_terms_list)) &&
				is.null(terms_list)
			) {
				warning(glue::glue(
					.sep = "\n",
					"Please supply either an explicit terms list",
					"where keys are terms and values accessions",
					"or a function which can generate such a list from the",
					"file, file_type, url, & version"
					# !! validate function arguments
				))
			}

			if (is.null(terms_list) && is.function(get_terms_list)) {
				self$terms_list <- self$get_terms_list(
					self$file, self$file_type, self$url, self$version
				)
			}

			if(!is.null(terms_list) && is.null(get_terms_list)) {
				self$terms_list <- terms_list
			}

			self$explicitly_provided <- explicitly_provided
			self$source <- source
		},
		#' @details
		#' Check if the name of the [OntologySource] is a string
		#' @param name The name of the [OntologySource]
		check_name = function(name) {
			check <- checkmate::check_string(name, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the name of the [OntologySource] if valid
		#' @param name The name of the [OntologySource]
		set_name = function(name) {
			if (self$check_name(name)) {
				self$name <- name
			}
		},
		#' @details
		#' Check if the file of the [OntologySource] is a string
		#' @param file The file of the [OntologySource]
		check_file = function(file) {
			check <- checkmate::check_string(file, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the file of the [OntologySource] if valid
		#' @param file The file of the [OntologySource]
		set_file = function(file) {
			if (self$check_file(file)) {
				self$file <- file
			}
		},
		#' @details
		#' Check if the file_type of the [OntologySource] is a string
		#' @param file_type The file_type of the [OntologySource]
		check_file_type = function(file_type) {
			check <- checkmate::check_string(file_type, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the file_type of the [OntologySource] if valid
		#' @param file_type The file_type of the [OntologySource]
		set_file_type = function(file_type) {
			if (self$check_file_type(file_type)) {
				self$file_type <- file_type
			}
		},
		#' @details
		#' Check if the url of the [OntologySource] is a string
		#' @param url The url of the [OntologySource]
		check_url = function(url) {
			check <- checkmate::check_string(url, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the url of the [OntologySource] if valid
		#' @param url The url of the [OntologySource]
		set_url = function(url) {
			if (self$check_url(url)) {
				self$url <- url
			}
		},
		#' @details
		#' Check if the version of the [OntologySource] is a string
		#' @param version The version of the [OntologySource]
		check_version = function(version) {
			check <- checkmate::check_string(version, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the version of the [OntologySource] if valid
		#' @param version The version of the [OntologySource]
		set_version = function(version) {
			if (self$check_version(version)) {
				self$version <- version
			}
		},
		#' @details
		#' Check if the description of the [OntologySource] is a string
		#' @param description The description of the [OntologySource]
		check_description = function(description) {
			check <- checkmate::check_string(description, min.chars = 1L)
			error_with_check_message_on_failure(check)
		},
		#' @details
		#' set the description of the [OntologySource] if valid
		#' @param description The description of the [OntologySource]
		set_description = function(description) {
			if (self$check_description(description)) {
				self$description <- description
			}
		},

		#' @details
		#' checks if comments are a named list of character vectors
		#' @param comments comments
		check_comments = function(comments) { check_comments(comments) },
		#' @details
		#' Sets comments if they are in a valid format
		#' @param comments a list of comments
		set_comments = function(comments) {
			if(self$check_comments(comments)) { self$comments <- comments }
		},
		#' @details
		#' Add comment if it is in a valid format
		#' @param comment a list of comments
		add_comment = function(comment) {
			if(self$check_comments(comment)) {
				self$comments <- c(comments, comment)
			}
		},
		#' @details
		#' Add terms to the [OntologySource]
		#' @param terms_list a list of terms with terms accessions as values
		add_terms = function(terms_list) {
			existing_terms_lgl <- names(terms_list) %in% names(self$terms_list)
			if(any(existing_terms_lgl)) {
				existing_terms <- names(terms_list[existing_terms_lgl])
				warning(paste(
					"These terms already exist:",
					paste(existing_terms, sep = ", ")
				))
			} else if(
				checkmate::test_list(
					terms_list, names = "unique"# types = "character",
				)# && all(purrr::map_lgl(terms_list, checkmate::test_string))
			) {
				self$terms_list <- c(self$terms_list, terms_list)
			} else {
				stop(
					"terms must be a uniquely named list",
					" of length 1 character vectors"
				)
			}
		},
		#' @details
		#'
		#' make an R list convertible to json
		#'
		#' @param json (default TRUE)
		to_list = function(json = TRUE) {
			if(json) {
				ontology_source_ref <- list(
					"file" = self$file,
					"description" = self$description,
					"name" = self$name,
					"version" = self$version#,
					#"comments" = self$comments
				)
			} else {
				ontology_source_ref <- list(
					"name" = self$name,
					"file" =  self$file,
					"file_type" =  self$file_type,
					"url" =  self$url,
					"version" = self$version,
					"description" = self$description,
					"comments" = self$comments,
					"terms_list" = self$terms_list,
					"get_terms_list" = rawToChar(
						serialize(self$get_terms_list, NULL, ascii = TRUE)
					)
				)
			}
			return(ontology_source_ref)
		},

		#' @details
		#'
		#' Make [OntologySource] from list
		#'
		#' @param lst an ontology source object serialized to a list
		#' @param json (default TRUE)
		from_list = function(lst, json = TRUE) {
			if(json) {
				self$name = lst[["name"]]
				self$file = lst[["file"]]
				# self$file_type = lst[["file_type"]]
				# self$url = lst[["url"]]
				self$version = lst[["version"]]
				self$description = lst[["description"]]
				self$comments = lst[["comments"]]
			} else {
				self$name = lst[["name"]]
				self$file = lst[["file"]]
				self$file_type = lst[["file_type"]]
				self$url = lst[["url"]]
				self$version = lst[["version"]]
				self$description = lst[["description"]]
				self$comments = lst[["comments"]]
				self$terms_list = lst[["terms_list"]]
				self$get_terms_list = unserialize(charToRaw(
					lst[["get_terms_list"]]
				))
			}
		},

		#' @details
		#' test if [OntologySource] is equivalent another OntologySource
		#' not necessarily an exactly identical object
		#' @param other_ontology_source another [OntologySource]
		is_same_ontology_as = function(other_ontology_source) {
			tests_lgl <- c(
				other_ontology_source$name == self$name,
				other_ontology_source$file == self$file,
				other_ontology_source$description == self$description
			)
			if(all(tests_lgl)) {
				if(other_ontology_source$version == self$version) {
					if(!identical(
						other_ontology_source$comments, self$comments
					)) {
						warning(
							"Comments differ! but everything else is",
							"the same consider merging the comments."
						)
					}
					return(TRUE)
				} else {
					message("Same Ontology Different Version")
					return(FALSE)
				}
			} else { return(FALSE) }
		},

		#' @details
		#' Pretty prints an [OntologySource] object
		print = function(){
			cli::cli_h1(cli::col_blue("Ontology Source"))
			green_bold_name_plain_content("Name", self$name)
			green_bold_name_plain_content("File", self$file)
			green_bold_name_plain_content("File Type", self$file_type)
			green_bold_name_plain_content("URL", self$url)
			green_bold_name_plain_content("Version", self$version)
			green_bold_name_plain_content(
				"Explicitly Provided", self$explicitly_provided
			)
			cli::cli_h2(cli::col_green("Description"))
			cli::cli_text(self$description) # indentation?
			pretty_print_comments(self$comments)
			cli::cli_h2(cli::col_green("Terms"))
			purrr::iwalk(
				head(self$terms_list),
				~cli::cli_text(paste0("    ", cli::style_bold(.y), ": ", .x))
			)
			cli::col_yellow(cli::style_italic(paste0(
				"    ... of: ", format(length(self$terms_list), big.mark = ",")
			)))
			#cat(green_bold("Terms:"), sep = "\n")
			# purrr::iwalk(
			# 	head(self$terms_list),
			# 	~cat(paste0("    ", crayon::bold(.y), ": ", .x), sep = "\n")
			# )
			# cat(crayon::yellow(crayon::italic(
			# 	"    ... of: ", format(length(self$terms_list), big.mark = ",")
			# )))
		}
	)
)

